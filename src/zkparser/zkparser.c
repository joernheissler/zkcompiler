#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <limits.h>
#include <ctype.h>

#include "zkparser/zkparser.h"
#include "zkparser/zkparser_internal.h"

#include "utils.c"
#include "string.c"
#include "varref.c"
#include "group.c"
#include "var.c"
#include "sigma.c"
#include "node.c"
#include "expression.c"
#include "hom.c"
#include "statementlist.c"


/* ugly hack to make zkparse() a function with internal linkage. If this ever makes trouble, remove the define/undef. */
#define zkparse i_want_zkparse_to_be_static(int); static int zkparse

/* include the grammar generated by bison */
#include "zkparser_grammar.c"
#undef zkparse

#include "lexer.c"

/** \brief if bison fails, display an error message
 ** \param sl the statementlist, unused.
 ** \param ls current state of character input function
 ** \param s error description from bison
 ** \return nothing
 **
 ** This function is called by zkparse on error (syntax error, memory allocation, etc.)
 **/
static void zkerror(YYLTYPE *loc, struct statementlist *sl, struct zk_lexstate *ls, struct zk_parserstate *ps, char const *s)
{
    (void) sl;
    (void) ps;
    (void) ls;
    fprintf(stderr, "In input %d:%d - %d:%d : %s\n", loc->first_line, loc->first_column, loc->last_line, loc->last_column, s);
}

/** \brief parse an input file
 ** \param getchr function which retrieves the next character from the input file
 ** \param arg argument to the character retrieval function
 ** \return pointer to a statementlist structure, which contains the parsed input or 0 on error
 **/
struct statementlist *zkparser_parse(int(*getchr)(void *), void *arg, struct identifier_callbacks *idcb)
{
    struct statementlist *sl;
    struct zk_lexstate state = { 0, 0, 1, 1, 0, { { 0, 0, 0 }, { 0, 0, 0 } } };
    struct zk_parserstate ps = { 0, 0, 0 };

    state.getchr = getchr;
    state.arg = arg;

    sl = statementlist_new(idcb);
    if(!sl) return 0;

    /* run parser code */
    if(zkparse(sl, &state, &ps)) {
        fprintf(stderr, "parser failed\n");
        statementlist_destruct(sl);
        return 0;
    }

    /* clean up remaining expressions in case the parser failed within `expr : expr' syntax */
    while(ps.tmp) {
        struct expression *prev = ps.tmp->prev;
        expression_destruct(ps.tmp);
        ps.tmp = prev;
    }

    return sl;
}

/** \brief free resources used by the statementlist
 ** \param list statementlist to free
 ** \return nothing
 **/
void zkparser_free(struct statementlist *list)
{
    statementlist_destruct(list);
}
