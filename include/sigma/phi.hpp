#ifndef ZK_SIGMA_PHI_HPP
#define ZK_SIGMA_PHI_HPP

#include "sigma/sigma.hpp"

using namespace ZKCompiler;

namespace ZKCompiler {
    namespace sigma {

        /*! \brief Phi protocol */
        class Phi : public Sigma {
            public:            
                /*! \brief Parser constructor
                 *
                 *    This constructor takes a parser configuration.
                 *
                 *  \param p pointer to Parser object
                 *  \param n Number of parameters (must be 4)
                 *  \param params String array of parameter names
                 *
                 *  expected arguments in params[]:
                 *  phi: name of a homomorphism
                 *  x  : public variable
                 *  w  : secret variable
                 *  c+ : upper border for challenges
                 */                
                Phi(Parser *p, unsigned int n, char *const params[]);

                /*! \brief Destructor for prover party 
                 *
                 *    Frees used memory by deleting Element objects.
                 */
                ~Phi();

                unsigned getCommitmentSize() const;
                void getCommitmentPtrs(const CMV::bnz_t* vpDst[], unsigned n) const;
                void setCommitment(const CMV::bnz_t* vpSrc[], unsigned n);
                unsigned getResponseSize() const;
                void getResponsePtrs(const CMV::bnz_t* vpDst[], unsigned n) const;
                void setResponse(const CMV::bnz_t* vpSrc[], unsigned n);

                /*! \brief Prover's P1 function 
                 *
                 *    First generates u random numbers and saves them to member
                 *  variable state.
                 *  The message r is calculated by phi(k_i)
                 */
                void P1();

                /*! \brief Prover's P2 function 
                 *
                 *    The prover's P2 function calculates the response and stores
                 *  the result in the member variable s.
                 *
                 *  Since s is from the additive group G, the calculation of
                 *  s := k + cw is done by first applying the group operation
                 *  c times on w by calling G's powz function and then doing a 
                 *  single operation k + cw to get the result.
                 *
                 */
                void P2();

                /*! \brief Verifier's V function 
                 *
                 *    To verify the response and so deciding if the proof
                 *  succeeds, the verifier test if the following equation
                 *  holds:
                 *  phi(s) =?= rx^c
                 *
                 *  To archieve this, two Elements from group G are generated
                 *  and each assigned to one side of the equation.
                 *  By again doing a dynamic cast, the results are compared
                 *  and the function returns "true" if they are equal and
                 *  false if they aren't.
                 *
                 */
                CMV::zk_bool_t V(bool interactive);
                
                /*! \brief Prover's S function 
                 *
                 *    This implements a simulator that generates accepting conversations.
                 *  In detail, the messages r, c and s are generated so that the 
                 *  verifier's V function accepts them as a valid conversation.
                 *  The message s is set to a random value and can be accessed by the
                 *  getResponse function. Since c is a needed for the calculation, it 
                 *  is inevitable to assign a value to the member variable c using
                 *  the setCallenge function. This is also the challenge message
                 *  mentioned in the beginning.
                 */
                void S();
                
                /*! \brief compute r from x,c,s; used by S and by noninteractive verifier */
                void R();


                /*! \brief Set commitment messages
                 *
                 *    Used to deliver the commitment message generated by the prover
                 *  to the verifier object. 
                 *  The Element parameter r is an Element from group H.
                 *
                 *    \param msg Commitment messages
                 */
                void setCommitment(Message msg);

                /*! \brief Set response messages
                 *
                 *    Used to deliver the response message generated by the prover
                 *  to the verifier object. 
                 *  The Element parameter s is an Element from group G.
                 *
                 *    \param msg Response messages
                 */
                void setResponse(Message msg);


                /*! \brief Get commitment messages 
                 *
                 *    Used to receive the commitment message from the prover object.
                 *  The parameter r is an Element from group H.
                 *
                 *    \return Message
                 */
                Message getCommitment();

                /*! \brief Get response messages 
                 *
                 *    The response message, which may be a tuple consisting of 
                 *  various Intgr Elements, is delivered to the parameter s of
                 *  this function.
                 *  This has to be done by using  a lot of dynamic casts by now.
                 *
                 *    \return Messages
                 */
                Message getResponse();
                
                /*! \brief Get public messages
                 *
                 *   get the public value x as a message
                 */
                Message getPublic();

                /*! \brief Checks whether or not a Sigma protocol needs to be simulated
                 * \returns false: no, true: yes
                 */
                bool simulationNeeded();

            private:
                /*! \brief Commitment messages */
                Element *r;

                /*! \brief Response messages */
                Element *s;

                /*! \brief Homomorphism to use */
                Hom *phi;

                /*! \brief Public known value */
                Element *x;

                /*! \brief Secret value */
                Element *w;

                /*! \brief state variable */
                Element *state;
        };
    }
}

#endif
